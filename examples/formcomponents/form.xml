<?xml version="1.0" encoding="iso-8859-1"?>
<!-- PHP2Go Examples : form.xml, used by formcomponents example -->
<!DOCTYPE form SYSTEM "..\..\docs\dtd\php2go_forms.dtd">
<form>

	<variable name="subset" default="1"/>

	<section name="PHP2Go Form Components Part 1" id="section">

		<combofield name="subset" label="Choose the Subset" default="~subset~">
			<option value="1" caption="Subset 1"/>
			<option value="2" caption="Subset 2"/>
			<option value="3" caption="Subset 3"/>
			<listener type="JS" event="onChange" action="window.location.href='?subset='+this.value"/>
		</combofield>

		<!--
			the rangefield represents a pair of values of the same data type.
			php2go automatically adds a validation rule that expects that the second value
			is greater (or greater or equal) than the first

			- to create a rangefield, you must specify 2 "editfield" child nodes
			- the "mask" attribute in "rangefield" will overwrite any mask defitions on "editfield" nodes
		-->
		<rangefield
			name="date_range" label="RangeField" mask="DATE" required="T"
			startname="start" endname="end" surroundtext="Between %s and %s"
		>
			<editfield/>
			<editfield/>
		</rangefield>

		<!--
			the editsearch widget is a combo which is filled with the results of a simple search.
			the search is performed by a simple search widget, based on a set of search fields and a search term.
			the search request is made with the JSRS library, bundled with PHP2Go

			- to create an editsearchfield, you must specifiy one "lookupfield" child, the query "datasource" and at least one "datafilter" child
			- the "expression" attribute inside the "datafilter" node represents how the filter will be added in the SQL condition clause
		-->
		<editsearchfield
			name="edit_search" label="EditSearchField"
			required="T" autotrim="T" autodispatch="T" debug="F"
		>
			<datafilter id="1" label="Name" expression="code like '%%%s%%'" mask="STRING"/>
			<datafilter id="2" label="Date Added" expression="date_added > '%s'" mask="DATE"/>
			<datasource>
				<keyfield>id_product</keyfield>
				<displayfield>concat(code,' - ',short_desc)</displayfield>
				<lookuptable>products</lookuptable>
			</datasource>
			<lookupfield width="350"/>
		</editsearchfield>

		<!--
			the multicolumnlookupfield is a special lookupfield that displays the available
			options in an table. <keyfield> will be used as component's value, and all fields
			declared inside <displayfield> will be visible inside the option's table
		-->
		<multicolumnlookupfield
			name="multi_column" label="MultiColumnLookupField"
			required="T" width="300" tablewidth="400" tableheight="250"
			headers="Name,Address,Category"
		>
			<datasource>
				<keyfield>client_id</keyfield>
				<displayfield>name, address, category</displayfield>
				<lookuptable>client</lookuptable>
				<orderby>name</orderby>
			</datasource>
		</multicolumnlookupfield>

		<!--
			the lookupchoicefield component extends lookupfield's features by adding a text
			input above the select input which filters the list options. the filter is
			applied using the "starts with" rule
		-->
		<lookupchoicefield
			name="lookup_choice" label="LookupChoiceField"
			required="T" width="300" size="5"
		>
			<datasource>
				<keyfield>client_id</keyfield>
				<displayfield>name</displayfield>
				<lookuptable>client</lookuptable>
				<orderby>name</orderby>
			</datasource>
		</lookupchoicefield>

		<!--
			text input with security image.
			used to test tell computers from humans apart.
		-->
		<captchafield
			name="captcha" label="CaptchaField" required="T"
			size="10" length="6" width="160" height="50"
			noiselevel="20" fontsize="20" fontshadow="4"
			imagepath="../tmp/" imagetype="IMAGETYPE_PNG"
		/>

		<!-- button group -->
		<buttons>
			<button name="submit" type="SUBMIT" value="Submit"/>
			<!--
				some form components execute special routines when form.reset() is called.
				this button was inserted here so that you can check these behaviours
			-->
			<button name="reset" type="RESET" value="Reset"/>
			<!--
				demonstration of a button whose JS action is inside the node's CDATA-section
				in this case, the JS code toggles enable state of all form fields
			-->
			<button name="disable" type="BUTTON" value="Disable">
				<listener type="JS" event="onClick"><![CDATA[
					if (typeof window.lastOp == 'undefined') {
						window.lastOp = false;
					} else {
						window.lastOp = !window.lastOp;
					}
					if (window.lastOp === true) {
						Form.enableAll('form');
						this.value = "Disable";
					} else {
						Form.disableAll('form');
						this.value = "Enable";
					}
				]]></listener>
			</button>
			<!-- back button -->
			<button name="back" type="BACK" value="Back"/>
		</buttons>

	</section>

</form>